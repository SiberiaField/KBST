При работе над проектом использовалась следующая литература:
 "Продвинутые алгоритмы и структуры данных", главы 2.6, 2.7, 9, Марчелло Ла Рокка.

--MAJOR_FUNCTIONS--
Основные функции и структуры, которые видны пользователю:

СТРУКТУРЫ:
struct pointData - это структура, хранящая данные одной точки: 
  double* coords - массив координат точки, длина массива должна соответсвовать мерности точки 
                   (для двухмерного пр-ва coords[0] координата по X, coords[1] координата по Y)
  char* name - имя точки
  int nameLen - длина имени
Эта структруа используется для обмена данными о точках с пользователем,
все функции принимают и возвращают данные о точках именно в этом формате.
Стоить отметить, что имя точки не является обязательным,
при его отсутствии нужно name = NULL и nameLen = 0.

struct KBSTnode - это структура, харнящая данные одной вершины в KBST:
  struct pointData point - данные о точке
  int level - уровень(глубина) вершины, используемая для определения разделяющей координаты вершины,
              по которой происходит сравнение с данной вершиной.
  struct KBSTnode* left - указатель на левого потомка
  struct KBSTnode* right - указатель на правого потомка
Всё дерево состоит из этих вершин.

ФУНКЦИИ:
"constructKBST.c"
--constructKBST--
KBSTnode* constructKBST (pointData* points, int num_of_points, int dimension, int level):
Эта функция создаёт сбалансированное(насколько это возможно) KBST из заданного массива точек,
заданной мерности. Также на вход подаётся уровень корня, благодаря чему можно создавать поддеревья.
  
Алгоритм:
  На каждом шаге выбирается медиана массива по одной из координат по принципу разбиения Ломуто, 
  затем, при помощи разбиения Хоара, массив делится на левое и правое поддеревья.
  При добавлении новой точки в дерево, память выделяется.
  
Входные данные:
  pointData* points - указатель на массив точек, из которого создаётся дерево (память выделяется)
  int num_of_points - размер массива
  int dimension - мерность дерева и точек соответсвенно
  int level - уровень корня

Выходные данные:
  Возвращает указатель на корень созданного дерева, 
  при вводе некорректных данных возвращается NULL

--swap--
static void swap(pointData* A, pointData* B):
Меняет значения двух точек местами.

Входные данные:
  pointData* A - указатель на первую точку
  pointData* B - указатель на вторую точку

--pivot--
static int pivot(pointData* points, int num_of_points, int cmp_coord):
Находит медиану в заданном массиве точек по принципу Ломуто.

Входные данные:
  pointData* points - указатель на массив точек, в котором ищется медиана
  int num_of_points - размер массива
  int cmp_coord - координата по которой ищется медиана 
                   (индекс в массиве coords точек по которой происходит сравнение)

Выходные данные:
  Возвращает индекс медианы массива points.

--partition--
static int partition (pointData* points, int num_of_points, int dimension, int level)
Эта функция разбивает заданный массив точек на две части при помощи разбиения Хоара.

Входные данные:
  pointData* points - указатель на массив точек
  int num_of_points - размер массива
  int dimension - мерность точек
  int level - глубина дерева на котором происходит разбиение, 
              нужно для определения разделяющей координаты

Выходные данные:
  Возвращает индекс медианы массива points.

"insertKBST.c"
--insertKBST--
KBSTnode* insertKBST (KBSTnode* head, pointData* new_point,  int dimension):
Эта функция вставялет в заданное дерево новую точку, заданной мерности.

Алгоритм:
  Функция работает также как и в обычным бинарных деревьях поиска(BST),
  единственным отличием является сравнение разных координат на разных уровнях дерева (читать README.md).
  При добавлении новой точки в дерево, память выделяется.

Входные данные:
  KBSTnode* head - указатель на вершину, с которой начинается вставка
  pointData* point - указатель на точку, которую хотим вставить
  int dimension - мерность дерева и точек соответсвенно

Выходные данные:
  Возвращает указаель на новую вершину,
  при вводе некорректных данных возвращается NULL

"searchKBST.c"
--searchKBST--
int searchKBST (KBSTnode* node, double* target, int dimension):
Эта функция выполняет поиск в дереве по заданным координатам точки.

Алгоритм:
  Функция работает также как и в обычным бинарных деревьях поиска(BST),
  единственным отличием является сравнение разных координат на разных уровнях дерева (читать README.md).

Входные данные:
  KBSTnode* node - указатель на вершину, с которой начинается поиск
  double* target - коордианты точки, котоую нужно найти
  int dimension - мерность дерева и точки соответственно

Выходные данные:
  Возрващает 1, если точка с заданными координатами есть в дереве и 0 в противном случае.

--eqPoints--
static int eqPoints(double* coords1, double* coords2, int dimension):
Поэлементно сравнивает координаты двух точек.

Входные данные:
  double* coords1 - массив координат первой точки
  double* coords2 - массив координат второй точки
  int dimension - мерность точек

Выходные данные:
  Возвращает 1 при полнои равенстве координат и 0 в противном случае.

"removeKBST.c"
--eqPoints--
Описано в --searchKBST--

--freeNode--
static void freeNode(KBSTnode* node):
Очищает поля node->point.coords и node->point.name

Входные данные:
  KBSTnode* node - указатель на очищаемую вершину
  
--minNode--
static KBSTnode* minNode(KBSTnode* A, KBSTnode* B, KBSTnode* C, int cmp_coord):
Возвращает минимальную, по заданной координате, точку из точек A, B, C. NULL указатели
воспринимает как бесконечные значения.

Входные данные:
  KBSTnode* A, B, C -  указатели на сравниваемые вершины из KBST.
  int cmp_coord - по какой координате идёт сравнение

Выходные данные:
  Возвращает указатель на минимальную вершину.

--findMin--
static KBSTnode* findMin(KBSTnode* node, int search_coord, int dimension):
Ищет вершину с миинмальным значением по заданной координате.

Алгоритм: читать указанную выше литературу.
  
Входные данные:
  KBSTnode* node - указатель на вершину, с которой начинается поиск
  int search_coord - по какой координате ищется минимальное значение
  int dimension - мерность дерева

Выходные данные:
  Возвращает указатель на найденную вершину.
  
--removeKBSTnode--
KBSTnode* removeKBSTnode(KBSTnode* node, double* target, int dimension):
Удаляет вершину с заданными координатами.

Алгоритм: читать указанную выше литературу.

Входные данные:
  KBSTnode* node - указатель на вершину откуда начинается поиск удаляемой вершины.
  double* target - массив координат удаляемой вершины
  int dimension - мерность дерева и точки соответсвенно

Выходные данные:
  Возвращает указатель на корень дерева, полученного после удаления вершины.

--removeKBST--
void removeKBST(KBSTnode* node):
Очищает всю память, выделенную под дерево с корнем в node.

Входные данные:
  KBSTnode* node - указатель на корень очищаемого дерева.

"nNearestNeighbor.c"
--nNearestNeighbor--
int nNearestNeighbor(KBSTnode* head, double* target, int dimension, int n, pointData** points, double** dists):
Эта функция ищет n ближайших соседей к точке с заданными координатами при помощи KBST, точка необязательно должна быть вершиной дерева.

Алгоритм: читать в, указанной выше, литературе

Входные данные:
  KBSTnode* head - указатель на корень дерева в котором осуществляется поиск
  double* target - массив координат относительно которых осуществляется поиск.
  int dimension - мерность дерева и точки соответсвенно
  int n - количество соседей
  pointData** points - адрес указателя на массив, в который будут сохранены найденные точки (память выделяется)
  double** dists - адрес указателя на массив, в который будут сохранены расстояния до найденных точек (память выделяется)

Выходные данные:
  Возвращает количество найденных точек. 
  При вводе некорректных данных возвращает 0.

--nNearestNeighbor_Rec--
static priQ nNearestNeighbor_Rec(KBSTnode* head, double* target, int dimension, priQ res):
Функция в которой реализован рекурсивный поиск n ближайших соседей. Эта функция вызывается в nNearestNeighbor,
после чего её значения выдаются пользователю.

Входные данные:
  KBST* head - указатель на корень дерева в котором осуществляется поиск
  double* target - массив координат относительно которых осуществляется поиск.
  int dimension - мерность дерева и точки соответсвенно
  priQ res - передаётся значение очереди приоритетов из прошлой итерации функции,
             подробнее про неё описано в разделе minor_functions ниже

Выходные значения:
  Возвращает очердеь приоритетов, с найденными на данной итерации ближайшими точками.

"pointInSphere.c"
--rescpy--
static void rescpy(doubleVec* A_dists, pointsVec* A_points, doubleVec* B_dists, pointsVec* B_points):
Эта функция добавляет значения из векторов B в концы вектороа A, после чего очищает вектора B

Входные данные:
  pointsVec* A_points - указатеь на вектор точек(pointData), куда добавятся значения из B_points
  doubleVec* A_dists - указатель на вектор растояний до центра(double), куда добавятся значения из B_dists
  doubleVec* B_dists - указатель на вектор растояний до центра(double), откуда берутся значения
  pointsVec* B_points - указатель на вектор точек(pointData), откуда берутся значения
  
--pointsInSphere_Rec--
static void pointsInSphere_Rec(KBSTnode* node, int dimension, double* center, double radius, pointsVec* points, doubleVec* dists):
Функция в которой реализован рекурсивный поиск точек, входящих в гиперсферу с заданным центром и радиусом. Эта функция вызывается в pointsInSphere,
после чего её значения выдаются пользователю.

Входные данные:
  KBSTnode* node - указатель на корень, в котором выполняется поиск
  int dimension - мерность дерева и гиперсферы соответсвенно
  double* center - указатель на массив координат центра гиперсферы
  double radius - радиус гиперсферы
  pointsVec* points - указатель на вектор точек(pointData), куда сохранятся результы вычислений
  doubleVec* dists - указатель на вектор расстояний до центра(double), куда сохранятся результаты вычислений
  Подробнее эти вектора описаны в разделе minor_functions

--pointInSphere--
int pointsInSphere(KBSTnode* node, int dimension, double* center, double radius, pointData** points, double** dists):
Эта функция ищет точки из дерева, входящие в гиперсферу с заданным центром и радиусом.

Входные данные:
  KBSTnode* node - Указатель на корень дерева в котором производится поиск
  int dimension - мерность дерева и гиперсферы соответсвенно 
  double* center - указатель на массив координат центра гиперсферы
  double radius - радиус гиперсферы
  pointData** points - адрес указателя на массив, куда сохраняются найденные точки (память выделяется)
  double** dists - адрес указателя на массив, куда сохраняются расстояния от найденных точек до центра гиперсферы (память выделяется)

Выходные данные:
  Возвращает количество найденных точек.

"pointInRectangle.c"
--inRectangle--
static int inRectangle(KBSTnode* node, int dimension, double* rectangle):
  Определяет, находится ли заданная точка в границах гиперпрямоугольника.

Входные данные:
  KBSTnode* node - указатель на вершину дерева, которую проверяем
  int dimension - мерность точки и гиперпрямоугольника соответственно
  double* rectangle - матрица размером (dimension x 2) через которую задаётся гиперпрямоугольник
                      (rectangle[i * 2] - нижняя грань по i-ой координате, rectangle[i * 2 + 1] - верхняя грань по i-ой координате)

Выходные данные:
  Возвращает 1, если точка лежит в гиперпрямоугольнике и 0 в противном случае.

--intersectLeft-- и --intersectRight--
static int intersectLeft(KBSTnode* node, int dimension, double* rectangle);
static int intersectRight(KBSTnode* node, int dimension, double* rectangle);
Обе эти функции определяют, с какой стороны от проекции на разделяющую координату точки
находится гиперпрямоугольник, иными словами, могут ли находится элементы из левого поддерева node
в гиперпрямоугольнике (intersectLeft), и соответсвенно элементы из правого поддерева node (intersectRight).

Входные данные:
  KBSTnode* node - указатель на вершину, относительно которой смотрим пересечение
  int dimension - мерность вершины и гиперпрямоугольника
  double* rectangle - матрица размером (dimension x 2) через которую задаётся гиперпрямоугольник
                      (rectangle[i * 2] - нижняя грань по i-ой координате, rectangle[i * 2 + 1] - верхняя грань по i-ой координате)

Выходные данные:
  Возвращают 1, если есть пересечение и 0 в противном случае.

--pointsInRectangle_Rec--
static pointsVec pointsInRectangle_Rec(KBSTnode* node, int dimension, double* rectangle):
Функция в которой реализован рекурсивный поиск точек, входящих в гиперпрямоугольник. Эта функция вызывается в pointsInRectangle,
после чего её значения выдаются пользователю.

Входные данные:
  KBSTnode* node - указатель на корень дерева, в котором происходит поиск
  ind dimension - мерность дерева и гиперпрямоугольника
  double* rectangle - матрица размером (dimension x 2) через которую задаётся гиперпрямоугольник
                      (rectangle[i * 2] - нижняя грань по i-ой координате, rectangle[i * 2 + 1] - верхняя грань по i-ой координате)

Выходные данные:
  Возвращает точки, найденные на данной итерации.
  
--pointsInRectangle--
int pointsInRectangle(KBSTnode* node, int dimension, double* rectangle, pointData** points):
Эта функция ищет точки из дерева, входящие в заданный гиперпрямоугольник.

Входные данные:
  KBSTnode* node - указатель на корень дерева, в котором выполняется поиск
  int dimension - мерность дерева и соответсвенно гиперпрямоугольника
  double* rectangle - матрица размером (dimension x 2) через которую задаётся гиперпрямоугольник 
                      (rectangle[i * 2] - нижняя грань по i-ой координате, rectangle[i * 2 + 1] - верхняя грань по i-ой координате)
  pointData** points - указатель на массив, в который будет сохранён рузультат вычислений (память выделяется)

Выходные данные:
  Возвращает количество найденных точек, при вводе некорректных данных возвращает 0


--MINOR_FUNCTIONS--
Вспомогательные функции и структуры, которые не видны пользователю:

"distance.c"
--abs_lf--
static double abs_lf(double num):
  Возвращает модуль заданного числа.

--splitDistance--
double splitDistance(KBSTnode* node, double* point, int dimension):
  Опрделяет расстояние от заданной точки до проекции разделяющей координаты вершины node.

Входные данные:
  KBSTnode* node - указатель на вершины, расстояние до которой определяем
  double* point - указатель на массив координат точки, от которой считаем расстояние
  int dimension - мерность вершины и точки

Выходные данные:
  Возвращает посчитанное расстояние

--distance--
double distance(double* A, double* B, int dimension):
  Считает расстояние между двумя точками.

Входные данные:
  double* A - указатель на массив координат первой точки
  doubel* B - указатель на массив координат второй точки
  int dimension - мерность точек

Выходные данные:
  Возвращает посчитанное расстояние.

"doubleVector.c"
struct doubleVec - это вектор вещественных значений
    double* arr - основной массив
    int cap - выделенное количество элементов
    int n - занятое количество элементов

--initDblVec--
void initDblVec(doubleVec* vec):
  Инициализирует вектор.

Входные данные:
  doubleVec* vec - указатель на вектор, который инициализируем

--destroyDblVec--
void destroyDblVec (doubleVec* vec):
  Очищает вектор и зануляет его поля.

Входные данные:
  doubleVec* vec - указатель на вектор, который очищаем

--pushDblVec--
void pushDblVec (doubleVec* vec, double value):
  Вставляет новый элемент в вектор.

Входные данные:
  doubleVec* vec - указатель на вектор, куда вставялем элемент
  double value - значение нового элемента

--veccpyDbl--
void veccpyDbl(doubleVec* where, doubleVec* from):
  Добавляет в конец вектора where все элементы вектора from.

Входные данные:
  doubleVec* where - указатель на вектор, в который копируем
  doubleVec* from - указатель на вектор, из которого копируем

"pointVector.c"
struct pointVec - это вектор значений точек
    pointData* arr - основной массив
    int cap - выделенное количество элементов
    int n - занятое количество элементов

--initDblVec--
void initPointVec(pointVec* vec):
  Инициализирует вектор.

Входные данные:
  pointVec* vec - указатель на вектор, который инициализируем

--destroyPointVec--
void destroyPointVec (pointVec* vec):
  Очищает вектор и зануляет его поля.

Входные данные:
  pointVec* vec - указатель на вектор, который очищаем

--pushPointVec--
void pushPointVec (pointVec* vec, pointData value):
  Вставляет новый элемент в вектор.

Входные данные:
  pointVec* vec - указатель на вектор, куда вставялем элемент
  pointData value - значение нового элемента

--veccpyPoint--
void veccpyPoint(pointVec* where, pointVec* from):
  Добавляет в конец вектора where все элементы вектора from.

Входные данные:
  pointVec* where - указатель на вектор, в который копируем
  pointVec* from - указатель на вектор, из которого копируем

"priorityQ.c"
struct priQ - очередь приоритетов, в нашем случае, невозрастающая бинарная куча на массиве, 
              она используется при нахождении n ближайших соседей в соответсвующей функции
    double* dists - массив расстояний от точек, по этим данным происходит сравнение в куче
    pointData* points - массив этих самых точек
    int cap - количество элементов выделенной память
    int n - количество элементов занятой памяти

--initPriQ--
void initPriQ(priQ* Q, int cap):
Эта функция инициализирует заданную очередь и выделяет массивы в ней размером cap

Входные данные:
 priQ* Q - указатель на корень кучи, которую инициализируем
 int cap - количество элементов

--siftUp--
static void siftUp(priQ* Q, int idx):
Просеивание кучи вверх.

Входные данные:
 priQ* Q - указатель на корень кучи, которую просеиваем
 int idx - индекс элемента, который нужно просеить

--highestPriChild--
static int highestPriChild(priQ* Q, int parent_idx):
Эта функция возрващает индекс потомка элемента с самым высоким приоритетом(значением dist)

Входные данные:
 priQ* Q - указатель на корень кучи
 int parent_idx - индекс родителя

Выходные данные:
 Описаны выше.

--firstLeafIdx--
static int firstLeafIdx(int priQ_size):
Эта функция возвращает индекс первого листа в куче.

Входные данные:
 int priQ_size - размер кучи

Выходные данные:
 Описаны выше.

--siftDown--
static void siftDown(priQ* Q, int idx):
Эта функция просеивает кучу вниз.

Входные данные:
 priQ* Q - указатель на корень кучи
 int idx - индекс элемента, который надо просеить

--topPriQ--
double topPriQ(priQ* Q, pointData* point):
Эта функция возвращает верхний элемент кучи и удаляет его.

Входные данные:
 priQ* Q - указатель на корень кучи
 pointData* point - указатель на элемент pointData, в который сохранится значение point верхнего элемента

Выходные данные:
 Возвращает значение dist верхнего элемента

--peekPriQ--
double peekPriQ(priQ* Q, pointData* point):
Эта функция возвращает верхний элемент кучи, но не удаляет его.
Данные аналогичны topPriQ.

--insertPriQ--
int insertPriQ(priQ* Q, double dist, pointData* point):
Эта функция вставляет новый элемент в кучу.

Входные данные:
 priQ* Q - указатель на корень кучи
 pointData* point - указатель на значение новой точки
 double dist - расстояние от этой точки

Выходные данные:
 1 - если вставка удачная, 0 - в противном случае.




  




  



  

